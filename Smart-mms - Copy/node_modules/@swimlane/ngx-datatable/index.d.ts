import * as i0 from '@angular/core';
import { Provider, PipeTransform, TemplateRef, EventEmitter, OnChanges, OnInit, OnDestroy, DoCheck, SimpleChanges, ChangeDetectorRef, TrackByFunction, AfterViewInit, AfterContentInit, QueryList, KeyValueDiffer, ViewContainerRef, ModuleWithProviders } from '@angular/core';
import { Subscription, Observable } from 'rxjs';
import { NgStyle } from '@angular/common';

/** Interface for messages to override default table texts. */
interface NgxDatatableMessages {
    /** Message to show when the array is present but empty */
    emptyMessage: string;
    /** Footer total message */
    totalMessage: string;
    /** Footer selected message */
    selectedMessage: string;
    /** Pager screen reader message for the first page button */
    ariaFirstPageMessage: string;
    /**
     * Pager screen reader message for the n-th page button.
     * It will be rendered as: `{{ariaPageNMessage}} {{n}}`.
     */
    ariaPageNMessage: string;
    /** Pager screen reader message for the previous page button */
    ariaPreviousPageMessage: string;
    /** Pager screen reader message for the next page button */
    ariaNextPageMessage: string;
    /** Pager screen reader message for the last page button */
    ariaLastPageMessage: string;
}
/** CSS classes for icons that override the default table icons. */
interface NgxDatatableCssClasses {
    sortAscending: string;
    sortDescending: string;
    sortUnset: string;
    pagerLeftArrow: string;
    pagerRightArrow: string;
    pagerPrevious: string;
    pagerNext: string;
}
/**
 * Interface definition for ngx-datatable global configuration
 */
interface NgxDatatableConfig {
    messages?: NgxDatatableMessages;
    cssClasses?: NgxDatatableCssClasses;
    headerHeight?: number;
    footerHeight?: number;
    rowHeight?: number;
    defaultColumnWidth?: number;
}
/**
 * This makes all properties recursively optional.
 *
 * @internal
 */
type AllPartial<T> = {
    [K in keyof T]?: AllPartial<T[K]>;
};
/**
 * Provides a global configuration for ngx-datatable.
 *
 * @param overrides The overrides of the table configuration.
 */
declare function providedNgxDatatableConfig(overrides: AllPartial<NgxDatatableConfig>): Provider;

/**
 * Column property that indicates how to retrieve this column's
 * value from a row.
 * 'a.deep.value', 'normalprop', 0 (numeric)
 */
type TableColumnProp = string | number;
/**
 * Column Type
 */
interface TableColumn<TRow extends Row = any> {
    /**
     * Determines if column is checkbox
     */
    checkboxable?: boolean;
    /**
     * Determines if the column is frozen to the left
     */
    frozenLeft?: boolean;
    /**
     * Determines if the column is frozen to the right
     */
    frozenRight?: boolean;
    /**
     * The grow factor relative to other columns. Same as the flex-grow
     * API from http =//www.w3.org/TR/css3-flexbox/. Basically;
     * take any available extra width and distribute it proportionally
     * according to all columns' flexGrow values.
     */
    flexGrow?: number;
    /**
     * Min width of the column
     */
    minWidth?: number;
    /**
     * Max width of the column
     */
    maxWidth?: number;
    /**
     * The default width of the column, in pixels
     */
    width?: number;
    /**
     * Can the column be resized
     */
    resizeable?: boolean;
    /**
     * Custom sort comparator
     */
    comparator?: (valueA: any, valueB: any, rowA: TRow, rowB: TRow, sortDir: 'desc' | 'asc') => number;
    /**
     * Custom pipe transforms
     */
    pipe?: PipeTransform;
    /**
     * Can the column be sorted
     */
    sortable?: boolean;
    /**
     * Can the column be re-arranged by dragging
     */
    draggable?: boolean;
    /**
     * Whether the column can automatically resize to fill space in the table.
     */
    canAutoResize?: boolean;
    /**
     * Column name or label
     */
    name?: string;
    /**
     * Property to bind to the row. Example:
     *
     * `someField` or `some.field.nested`, 0 (numeric)
     *
     * If left blank, will use the name as camel case conversion
     */
    prop?: TableColumnProp;
    /**
     * By default, the property is bound using normal data binding `<span>{{content}}</span>`.
     * If this property is set to true, the property will be bound as `<span [innerHTML]="content" />`.
     *
     * **DANGER** If enabling this feature, make sure the source of the data is trusted. This can be a vector for HTML injection attacks.
     */
    bindAsUnsafeHtml?: boolean;
    /**
     * Cell template ref
     */
    cellTemplate?: TemplateRef<CellContext<TRow>>;
    /**
     * Ghost Cell template ref
     */
    ghostCellTemplate?: TemplateRef<any>;
    /**
     * Header template ref
     */
    headerTemplate?: TemplateRef<HeaderCellContext>;
    /**
     * Tree toggle template ref
     */
    treeToggleTemplate?: any;
    /**
     * CSS Classes for the cell
     */
    cellClass?: string | ((data: {
        row: TRow;
        group?: TRow[];
        column: TableColumn<TRow>;
        value: any;
        rowHeight: number;
    }) => string | Record<string, boolean>);
    /**
     * CSS classes for the header
     */
    headerClass?: string | ((data: {
        column: TableColumn;
    }) => string | Record<string, boolean>);
    /**
     * Header checkbox enabled
     */
    headerCheckboxable?: boolean;
    /**
     * Is tree displayed on this column
     */
    isTreeColumn?: boolean;
    /**
     * Width of the tree level indent
     */
    treeLevelIndent?: number;
    /**
     * Summary function
     *
     * Null and undefined have different meanings:
     *  - undefined will use the default summary function
     *  - null will not compute a summary
     */
    summaryFunc?: ((cells: any[]) => any) | null;
    /**
     * Summary cell template ref
     */
    summaryTemplate?: TemplateRef<any>;
}

interface SortPropDir {
    dir: SortDirection | 'desc' | 'asc';
    prop: TableColumnProp;
}
declare enum SortDirection {
    asc = "asc",
    desc = "desc"
}
interface SortEvent {
    column: TableColumn;
    prevValue: SortDirection | undefined;
    newValue: SortDirection | undefined;
    sorts: SortPropDir[];
}
declare enum SortType {
    single = "single",
    multi = "multi"
}
declare enum ColumnMode {
    standard = "standard",
    flex = "flex",
    force = "force"
}
type TreeStatus = 'collapsed' | 'expanded' | 'loading' | 'disabled';
interface ActivateEvent<TRow> {
    type: 'checkbox' | 'click' | 'dblclick' | 'keydown' | 'mouseenter';
    event: Event;
    row: TRow;
    group?: TRow[];
    rowHeight?: number;
    column?: TableColumn;
    value?: any;
    cellElement?: HTMLElement;
    treeStatus?: TreeStatus;
    cellIndex?: number;
    rowElement: HTMLElement;
}
interface HeaderCellContext {
    column: TableColumn;
    sortDir: SortDirection | 'asc' | 'desc' | undefined;
    sortFn: () => void;
    allRowsSelected?: boolean;
    selectFn: () => void;
}
interface GroupContext<TRow extends Row = any> {
    group: Group<TRow>;
    expanded: boolean;
    rowIndex: number;
}
interface CellContext<TRow extends Row = any> {
    onCheckboxChangeFn: (event: Event) => void;
    activateFn: (event: ActivateEvent<TRow>) => void;
    row: TRow;
    group?: TRow[];
    value: any;
    column: TableColumn;
    rowHeight: number;
    isSelected?: boolean;
    rowIndex: number;
    rowInGroupIndex?: number;
    treeStatus?: TreeStatus;
    disabled?: boolean;
    onTreeAction: () => void;
    expanded?: boolean;
}
interface FooterContext {
    rowCount: number;
    pageSize: number;
    selectedCount: number;
    curPage: number;
    offset: number;
}
declare enum ContextmenuType {
    header = "header",
    body = "body"
}
/** A Group row */
interface Group<TRow> {
    /** The value by which to rows are grouped. */
    key: TRow[keyof TRow];
    /** All rows that are part of the group. */
    value: TRow[];
}
/** Type for either a row or a group */
type RowOrGroup<TRow> = TRow | Group<TRow>;
interface RowDetailContext<TRow extends Row = any> {
    row: TRow;
    expanded: boolean;
    rowIndex: number;
    disabled?: boolean;
}
/**
 * Consumer provided rows should extend this interface
 * to get access to implicit row properties which are set by the datatable if required.
 */
interface Row {
    [key: TableColumnProp]: any;
    treeStatus?: TreeStatus;
    level?: number;
}
interface ReorderEvent {
    column: TableColumn;
    prevValue: number;
    newValue: number;
}
interface PageEvent {
    count: number;
    pageSize: number;
    /** @deprecated Use {@link pageSize} instead. */
    limit: number | undefined;
    offset: number;
    sorts: SortPropDir[];
}
interface PagerPageEvent {
    page: number;
}
interface ColumnResizeEvent {
    column: TableColumn;
    prevValue: number;
    newValue: number;
}
interface ScrollEvent {
    offsetY: number;
    offsetX: number;
}
interface GroupToggleEvent<TRow> {
    type: 'group';
    value: Group<TRow>;
}
interface AllGroupsToggleEvent {
    type: 'all';
    value: boolean;
}
type GroupToggleEvents<TRow> = GroupToggleEvent<TRow> | AllGroupsToggleEvent;
interface DetailToggleEvent<TRow> {
    type: 'row';
    value: TRow;
}
interface AllDetailToggleEvent {
    type: 'all';
    value: boolean;
}
type DetailToggleEvents<TRow> = DetailToggleEvent<TRow> | AllDetailToggleEvent;
declare enum SelectionType {
    single = "single",
    multi = "multi",
    multiClick = "multiClick",
    cell = "cell",
    checkbox = "checkbox"
}
interface SelectEvent<TRow> {
    selected: TRow[];
}
interface ContextMenuEventBody<TRow> {
    event: MouseEvent;
    type: ContextmenuType.body;
    content: RowOrGroup<TRow>;
}
interface ContextMenuEvenHeader {
    event: MouseEvent;
    type: ContextmenuType.header;
    content: TableColumn;
}
type ContextMenuEvent<TRow> = ContextMenuEventBody<TRow> | ContextMenuEvenHeader;
type DragEventType = 'drag' | 'dragend' | 'dragenter' | 'dragleave' | 'dragover' | 'dragstart' | 'drop';
interface DragEventData {
    event: DragEvent;
    srcElement: HTMLElement;
    targetElement?: HTMLElement;
    eventType: DragEventType;
    dragRow: any;
    dropRow?: any;
}

declare class DataTableFooterTemplateDirective {
    static ngTemplateContextGuard(directive: DataTableFooterTemplateDirective, context: unknown): context is FooterContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableFooterTemplateDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableFooterTemplateDirective, "[ngx-datatable-footer-template]", never, {}, {}, never, never, true, never>;
}

declare class DatatableGroupHeaderDirective<TRow extends Row = any> {
    /**
     * Row height is required when virtual scroll is enabled.
     */
    rowHeight: number | ((group?: Group<TRow>, index?: number) => number);
    /**
     * Show checkbox at group header to select all rows of the group.
     */
    checkboxable: boolean;
    _templateInput?: TemplateRef<GroupContext<TRow>>;
    _templateQuery?: TemplateRef<GroupContext<TRow>>;
    get template(): TemplateRef<GroupContext<TRow>> | undefined;
    /**
     * Track toggling of group visibility
     */
    toggle: EventEmitter<GroupToggleEvents<TRow>>;
    /**
     * Toggle the expansion of a group
     */
    toggleExpandGroup(group: Group<TRow>): void;
    /**
     * Expand all groups
     */
    expandAllGroups(): void;
    /**
     * Collapse all groups
     */
    collapseAllGroups(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableGroupHeaderDirective<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableGroupHeaderDirective<any>, "ngx-datatable-group-header", never, { "rowHeight": { "alias": "rowHeight"; "required": false; }; "checkboxable": { "alias": "checkboxable"; "required": false; }; "_templateInput": { "alias": "template"; "required": false; }; }, { "toggle": "toggle"; }, ["_templateQuery"], never, true, never>;
}

declare class DataTableColumnDirective<TRow extends Row> implements TableColumn, OnChanges {
    private columnChangesService;
    name?: string;
    prop?: TableColumnProp;
    bindAsUnsafeHtml?: boolean;
    frozenLeft?: boolean;
    frozenRight?: boolean;
    flexGrow?: number;
    resizeable?: boolean;
    comparator?: (valueA: any, valueB: any, rowA: TRow, rowB: TRow, sortDir: 'desc' | 'asc') => number;
    pipe?: PipeTransform;
    sortable?: boolean;
    draggable?: boolean;
    canAutoResize?: boolean;
    minWidth?: number;
    width?: number;
    maxWidth?: number;
    checkboxable?: boolean;
    headerCheckboxable?: boolean;
    headerClass?: string | ((data: {
        column: TableColumn;
    }) => string | Record<string, boolean>);
    cellClass?: string | ((data: {
        row: TRow;
        group?: TRow[];
        column: TableColumn<TRow>;
        value: any;
        rowHeight: number;
    }) => string | Record<string, boolean>);
    isTreeColumn?: boolean;
    treeLevelIndent?: number;
    summaryFunc?: (cells: any[]) => any;
    summaryTemplate?: TemplateRef<any>;
    _cellTemplateInput?: TemplateRef<CellContext<TRow>>;
    _cellTemplateQuery?: TemplateRef<CellContext<TRow>>;
    get cellTemplate(): TemplateRef<CellContext<TRow>> | undefined;
    _headerTemplateInput?: TemplateRef<HeaderCellContext>;
    _headerTemplateQuery?: TemplateRef<HeaderCellContext>;
    get headerTemplate(): TemplateRef<HeaderCellContext> | undefined;
    _treeToggleTemplateInput?: TemplateRef<any>;
    _treeToggleTemplateQuery?: TemplateRef<any>;
    get treeToggleTemplate(): TemplateRef<any> | undefined;
    _ghostCellTemplateInput?: TemplateRef<void>;
    _ghostCellTemplateQuery?: TemplateRef<void>;
    get ghostCellTemplate(): TemplateRef<void> | undefined;
    private isFirstChange;
    ngOnChanges(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableColumnDirective<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableColumnDirective<any>, "ngx-datatable-column", never, { "name": { "alias": "name"; "required": false; }; "prop": { "alias": "prop"; "required": false; }; "bindAsUnsafeHtml": { "alias": "bindAsUnsafeHtml"; "required": false; }; "frozenLeft": { "alias": "frozenLeft"; "required": false; }; "frozenRight": { "alias": "frozenRight"; "required": false; }; "flexGrow": { "alias": "flexGrow"; "required": false; }; "resizeable": { "alias": "resizeable"; "required": false; }; "comparator": { "alias": "comparator"; "required": false; }; "pipe": { "alias": "pipe"; "required": false; }; "sortable": { "alias": "sortable"; "required": false; }; "draggable": { "alias": "draggable"; "required": false; }; "canAutoResize": { "alias": "canAutoResize"; "required": false; }; "minWidth": { "alias": "minWidth"; "required": false; }; "width": { "alias": "width"; "required": false; }; "maxWidth": { "alias": "maxWidth"; "required": false; }; "checkboxable": { "alias": "checkboxable"; "required": false; }; "headerCheckboxable": { "alias": "headerCheckboxable"; "required": false; }; "headerClass": { "alias": "headerClass"; "required": false; }; "cellClass": { "alias": "cellClass"; "required": false; }; "isTreeColumn": { "alias": "isTreeColumn"; "required": false; }; "treeLevelIndent": { "alias": "treeLevelIndent"; "required": false; }; "summaryFunc": { "alias": "summaryFunc"; "required": false; }; "summaryTemplate": { "alias": "summaryTemplate"; "required": false; }; "_cellTemplateInput": { "alias": "cellTemplate"; "required": false; }; "_headerTemplateInput": { "alias": "headerTemplate"; "required": false; }; "_treeToggleTemplateInput": { "alias": "treeToggleTemplate"; "required": false; }; "_ghostCellTemplateInput": { "alias": "ghostCellTemplate"; "required": false; }; }, {}, ["_cellTemplateQuery", "_headerTemplateQuery", "_treeToggleTemplateQuery", "_ghostCellTemplateQuery"], never, true, never>;
    static ngAcceptInputType_bindAsUnsafeHtml: unknown;
    static ngAcceptInputType_frozenLeft: unknown;
    static ngAcceptInputType_frozenRight: unknown;
    static ngAcceptInputType_flexGrow: unknown;
    static ngAcceptInputType_resizeable: unknown;
    static ngAcceptInputType_sortable: unknown;
    static ngAcceptInputType_draggable: unknown;
    static ngAcceptInputType_canAutoResize: unknown;
    static ngAcceptInputType_minWidth: unknown;
    static ngAcceptInputType_width: unknown;
    static ngAcceptInputType_maxWidth: unknown;
    static ngAcceptInputType_checkboxable: unknown;
    static ngAcceptInputType_headerCheckboxable: unknown;
    static ngAcceptInputType_isTreeColumn: unknown;
}

declare class DatatableRowDetailDirective<TRow extends Row = any> {
    /**
     * The detail row height is required especially
     * when virtual scroll is enabled.
     */
    rowHeight: number | ((row?: TRow, index?: number) => number);
    _templateInput?: TemplateRef<RowDetailContext<TRow>>;
    _templateQuery?: TemplateRef<RowDetailContext<TRow>>;
    get template(): TemplateRef<RowDetailContext<TRow>> | undefined;
    /**
     * Row detail row visbility was toggled.
     */
    toggle: EventEmitter<DetailToggleEvents<TRow>>;
    /**
     * Toggle the expansion of the row
     */
    toggleExpandRow(row: TRow): void;
    /**
     * API method to expand all the rows.
     */
    expandAllRows(): void;
    /**
     * API method to collapse all the rows.
     */
    collapseAllRows(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDetailDirective<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDetailDirective<any>, "ngx-datatable-row-detail", never, { "rowHeight": { "alias": "rowHeight"; "required": false; }; "_templateInput": { "alias": "template"; "required": false; }; }, { "toggle": "toggle"; }, ["_templateQuery"], never, true, never>;
}

declare class DatatableFooterDirective {
    _templateInput?: TemplateRef<FooterContext>;
    _templateQuery?: TemplateRef<FooterContext>;
    get template(): TemplateRef<FooterContext> | undefined;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableFooterDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableFooterDirective, "ngx-datatable-footer", never, { "_templateInput": { "alias": "template"; "required": false; }; }, {}, ["_templateQuery"], never, true, never>;
}

declare class ScrollerComponent implements OnInit, OnDestroy {
    private renderer;
    scrollbarV?: boolean;
    scrollbarH?: boolean;
    scrollHeight?: number;
    scrollWidth?: number;
    scroll: EventEmitter<any>;
    scrollYPos: number;
    scrollXPos: number;
    prevScrollYPos: number;
    prevScrollXPos: number;
    element: HTMLElement;
    parentElement?: HTMLElement;
    private _scrollEventListener;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setOffset(offsetY: number): void;
    onScrolled(event: MouseEvent): void;
    updateOffset(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollerComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<ScrollerComponent, "datatable-scroller", never, { "scrollbarV": { "alias": "scrollbarV"; "required": false; }; "scrollbarH": { "alias": "scrollbarH"; "required": false; }; "scrollHeight": { "alias": "scrollHeight"; "required": false; }; "scrollWidth": { "alias": "scrollWidth"; "required": false; }; }, { "scroll": "scroll"; }, never, ["*"], true, never>;
}

/**
 * This object contains the cache of the various row heights that are present inside
 * the data table.   Its based on Fenwick tree data structure that helps with
 * querying sums that have time complexity of log n.
 *
 * Fenwick Tree Credits: http://petr-mitrichev.blogspot.com/2013/05/fenwick-tree-range-updates.html
 * https://github.com/mikolalysenko/fenwick-tree
 *
 */
declare class RowHeightCache {
    /**
     * Tree Array stores the cumulative information of the row heights to perform efficient
     * range queries and updates.  Currently the tree is initialized to the base row
     * height instead of the detail row height.
     */
    private treeArray;
    /**
     * Clear the Tree array.
     */
    clearCache(): void;
    /**
     * Initialize the Fenwick tree with row Heights.
     *
     * @param rows The array of rows which contain the expanded status.
     * @param rowHeight The row height.
     * @param detailRowHeight The detail row height.
     */
    initCache(details: any): void;
    /**
     * Given the ScrollY position i.e. sum, provide the rowIndex
     * that is present in the current view port.  Below handles edge cases.
     */
    getRowIndex(scrollY: number): number;
    /**
     * When a row is expanded or rowHeight is changed, update the height.  This can
     * be utilized in future when Angular Data table supports dynamic row heights.
     */
    update(atRowIndex: number, byRowHeight: number): void;
    /**
     * Range Sum query from 1 to the rowIndex
     */
    query(atIndex: number): number;
    /**
     * Find the total height between 2 row indexes
     */
    queryBetween(atIndexA: number, atIndexB: number): number;
    /**
     * Given the ScrollY position i.e. sum, provide the rowIndex
     * that is present in the current view port.
     */
    private calcRowIndex;
}

type ValueGetter = (obj: any, prop: TableColumnProp) => any;

type PinDirection = 'left' | 'center' | 'right';
interface PinnedColumns {
    type: PinDirection;
    columns: TableColumnInternal[];
}
interface ColumnGroupWidth {
    left: number;
    center: number;
    right: number;
    total: number;
}
interface TargetChangedEvent {
    newIndex?: number;
    prevIndex: number;
    initialIndex: number;
}
interface ColumnResizeEventInternal {
    column: TableColumnInternal;
    prevValue: number;
    newValue: number;
}
interface ReorderEventInternal {
    column: TableColumnInternal;
    prevValue: number;
    newValue: number;
}
interface InnerSortEvent {
    column: SortableTableColumnInternal;
    prevValue: SortDirection | undefined;
    newValue: SortDirection | undefined;
}
interface CellActiveEvent<TRow> {
    type: 'checkbox' | 'click' | 'dblclick' | 'keydown' | 'mouseenter';
    event: Event;
    row: TRow;
    group?: TRow[];
    rowHeight?: number;
    column?: TableColumn;
    value?: any;
    cellElement?: HTMLElement;
    treeStatus?: TreeStatus;
}
interface BaseTableColumnInternal<TRow extends Row = any> extends TableColumn<TRow> {
    /** Internal unique id */
    $$id: string;
    /** Internal for column width distributions */
    $$oldWidth?: number;
    /** Internal for setColumnDefaults */
    $$valueGetter: ValueGetter;
    dragging?: boolean;
    isTarget?: boolean;
    targetMarkerContext?: any;
    name: string;
    width: number;
}
interface StandardTableColumnInternal<TRow extends Row = any> extends BaseTableColumnInternal<TRow> {
    sortable?: false;
}
interface SortableTableColumnInternal<TRow extends Row = any> extends BaseTableColumnInternal<TRow> {
    comparator: Exclude<TableColumn['comparator'], undefined>;
    prop: TableColumnProp;
    sortable: true;
}
type TableColumnInternal<TRow extends Row = any> = StandardTableColumnInternal<TRow> | SortableTableColumnInternal<TRow>;
/** Represents the index of a row. */
interface RowIndex {
    /** Index of the row. If the row is inside a group, it will hold the index the group. */
    index: number;
    /** Index of a row inside a group. Only present if the row is inside a group. */
    indexInGroup?: number;
}

declare class DataTableBodyRowComponent<TRow extends Row = any> implements DoCheck, OnChanges {
    private cd;
    set columns(val: TableColumnInternal[]);
    get columns(): TableColumnInternal[];
    set innerWidth(val: number);
    get innerWidth(): number;
    expanded?: boolean;
    rowClass?: (row: TRow) => string | Record<string, boolean>;
    row: TRow;
    group?: TRow[];
    isSelected?: boolean;
    rowIndex: RowIndex;
    displayCheck?: (row: TRow, column: TableColumnInternal, value?: any) => boolean;
    treeStatus?: TreeStatus;
    verticalScrollVisible: boolean;
    disabled?: boolean;
    get cssClass(): string;
    rowHeight: number;
    get columnsTotalWidths(): number;
    activate: EventEmitter<ActivateEvent<TRow>>;
    treeAction: EventEmitter<any>;
    _element: HTMLElement;
    _columnGroupWidths: ColumnGroupWidth;
    _columnsByPin: PinnedColumns[];
    _columns: TableColumnInternal[];
    _innerWidth: number;
    private _rowDiffer;
    ngOnChanges(changes: SimpleChanges): void;
    ngDoCheck(): void;
    onActivate(event: CellActiveEvent<TRow>, index: number): void;
    onKeyDown(event: KeyboardEvent): void;
    onMouseenter(event: MouseEvent): void;
    recalculateColumns(val?: TableColumnInternal<TRow>[]): void;
    onTreeAction(): void;
    /** Returns the row index, or if in a group, the index within a group. */
    private get innerRowIndex();
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableBodyRowComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DataTableBodyRowComponent<any>, "datatable-body-row", never, { "columns": { "alias": "columns"; "required": false; }; "innerWidth": { "alias": "innerWidth"; "required": false; }; "expanded": { "alias": "expanded"; "required": false; }; "rowClass": { "alias": "rowClass"; "required": false; }; "row": { "alias": "row"; "required": false; }; "group": { "alias": "group"; "required": false; }; "isSelected": { "alias": "isSelected"; "required": false; }; "rowIndex": { "alias": "rowIndex"; "required": false; }; "displayCheck": { "alias": "displayCheck"; "required": false; }; "treeStatus": { "alias": "treeStatus"; "required": false; }; "verticalScrollVisible": { "alias": "verticalScrollVisible"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "rowHeight": { "alias": "rowHeight"; "required": false; }; }, { "activate": "activate"; "treeAction": "treeAction"; }, never, never, true, never>;
}

declare enum Keys {
    up = "ArrowUp",
    down = "ArrowDown",
    return = "Enter",
    escape = "Escape",
    left = "ArrowLeft",
    right = "ArrowRight"
}

declare class DataTableBodyComponent<TRow extends Row = any> implements OnInit, OnDestroy {
    cd: ChangeDetectorRef;
    rowDefTemplate?: TemplateRef<any>;
    scrollbarV?: boolean;
    scrollbarH?: boolean;
    loadingIndicator?: boolean;
    ghostLoadingIndicator?: boolean;
    externalPaging?: boolean;
    rowHeight: number | 'auto' | ((row?: any) => number);
    offsetX: number;
    selectionType?: SelectionType;
    selected: any[];
    rowIdentity: (x: RowOrGroup<TRow>) => unknown;
    rowDetail?: DatatableRowDetailDirective;
    groupHeader?: DatatableGroupHeaderDirective;
    selectCheck?: (value: TRow, index: number, array: TRow[]) => boolean;
    displayCheck?: (row: TRow, column: TableColumnInternal, value?: any) => boolean;
    trackByProp?: string;
    rowClass?: (row: TRow) => string | Record<string, boolean>;
    groupedRows?: Group<TRow>[];
    groupExpansionDefault?: boolean;
    innerWidth: number;
    groupRowsBy?: keyof TRow;
    virtualization?: boolean;
    summaryRow?: boolean;
    summaryPosition: string;
    summaryHeight: number;
    rowDraggable?: boolean;
    rowDragEvents: EventEmitter<DragEventData>;
    disableRowCheck?: (row: TRow) => boolean | undefined;
    set pageSize(val: number);
    get pageSize(): number;
    set rows(val: (TRow | undefined)[]);
    get rows(): (TRow | undefined)[];
    set columns(val: TableColumnInternal[]);
    get columns(): any[];
    set offset(val: number);
    get offset(): number;
    set rowCount(val: number);
    get rowCount(): number;
    get bodyWidth(): string;
    set bodyHeight(val: number | string);
    get bodyHeight(): number | string;
    verticalScrollVisible: boolean;
    scroll: EventEmitter<ScrollEvent>;
    page: EventEmitter<number>;
    activate: EventEmitter<ActivateEvent<TRow>>;
    select: EventEmitter<SelectEvent<TRow>>;
    rowContextmenu: EventEmitter<{
        event: MouseEvent;
        row: RowOrGroup<TRow>;
    }>;
    treeAction: EventEmitter<{
        row: TRow;
    }>;
    scroller: ScrollerComponent;
    /**
     * Returns if selection is enabled.
     */
    get selectEnabled(): boolean;
    /**
     * Property that would calculate the height of scroll bar
     * based on the row heights cache for virtual scroll and virtualization. Other scenarios
     * calculate scroll height automatically (as height will be undefined).
     */
    scrollHeight: i0.Signal<number>;
    rowsToRender: i0.Signal<RowOrGroup<TRow>[]>;
    rowHeightsCache: i0.WritableSignal<RowHeightCache>;
    offsetY: number;
    indexes: i0.WritableSignal<{
        first: number;
        last: number;
    }>;
    columnGroupWidths: ColumnGroupWidth;
    rowTrackingFn: TrackByFunction<RowOrGroup<TRow> | undefined>;
    listener: any;
    rowExpansions: any[];
    _rows: (TRow | undefined)[];
    _bodyHeight: string;
    _columns: TableColumnInternal[];
    _rowCount: number;
    _offset: number;
    _pageSize: number;
    _offsetEvent: number;
    private _draggedRow?;
    private _draggedRowElement?;
    /**
     * Creates an instance of DataTableBodyComponent.
     */
    constructor();
    /**
     * Called after the constructor, initializing input properties
     */
    ngOnInit(): void;
    private toggleStateChange;
    /**
     * Called once, before the instance is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Updates the Y offset given a new offset.
     */
    updateOffsetY(offset?: number): void;
    /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     */
    onBodyScroll(event: any): void;
    /**
     * Updates the page given a direction.
     */
    updatePage(direction: string): void;
    /**
     * Updates the rows in the view port
     */
    updateRows(): (RowOrGroup<TRow> | undefined)[];
    /**
     * Get the row height
     */
    getRowHeight(row: RowOrGroup<TRow>): number;
    /**
     * @param group the group with all rows
     */
    getGroupHeight(group: Group<TRow>): number;
    /**
     * Calculate row height based on the expanded state of the row.
     */
    getRowAndDetailHeight(row: TRow): number;
    /**
     * Get the height of the detail row.
     */
    getDetailRowHeight: (row?: TRow, index?: number) => number;
    getGroupHeaderRowHeight: (row?: any, index?: any) => number;
    /**
     * Calculates the offset of the rendered rows.
     * As virtual rows are not shown, we have to move all rendered rows
     * by the total size of previous non-rendered rows.
     * If each row has a size of 10px and the first 10 rows are not rendered due to scroll,
     * then we have a renderOffset of 100px.
     */
    renderOffset: i0.Signal<string>;
    /**
     * Updates the index of the rows in the viewport
     */
    updateIndexes(): void;
    /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     */
    refreshRowHeightCache(): void;
    /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     */
    toggleRowExpansion(row: TRow): void;
    /**
     * Expand/Collapse all the rows no matter what their state is.
     */
    toggleAllRows(expanded: boolean): void;
    /**
     * Recalculates the table
     */
    recalcLayout(): void;
    /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     */
    getRowExpanded(row: RowOrGroup<TRow>): boolean;
    getRowExpandedIdx(row: RowOrGroup<TRow>, expanded: RowOrGroup<TRow>[]): number;
    onTreeAction(row: TRow): void;
    dragOver(event: DragEvent, dropRow: RowOrGroup<TRow>): void;
    drag(event: DragEvent, dragRow: RowOrGroup<TRow>, rowComponent: DataTableBodyRowComponent<TRow>): void;
    drop(event: DragEvent, dropRow: RowOrGroup<TRow>, rowComponent: DataTableBodyRowComponent<TRow>): void;
    dragEnter(event: DragEvent, dropRow: RowOrGroup<TRow>, rowComponent: DataTableBodyRowComponent<TRow>): void;
    dragLeave(event: DragEvent, dropRow: RowOrGroup<TRow>, rowComponent: DataTableBodyRowComponent<TRow>): void;
    dragEnd(event: DragEvent, dragRow: RowOrGroup<TRow>): void;
    updateColumnGroupWidths(): void;
    prevIndex?: number;
    selectRow(event: Event, index: number, row: TRow): void;
    onActivate(model: ActivateEvent<TRow>, index: number): void;
    onKeyboardFocus(model: ActivateEvent<TRow>): void;
    focusRow(rowElement: HTMLElement, key: Keys): void;
    getPrevNextRow(rowElement: HTMLElement, key: Keys): any;
    focusCell(cellElement: HTMLElement, rowElement: HTMLElement, key: Keys, cellIndex: number): void;
    getRowSelected(row: TRow): boolean;
    getRowSelectedIdx(row: TRow, selected: any[]): number;
    protected isGroup(row: RowOrGroup<TRow>[]): row is Group<TRow>[];
    protected isGroup(row: RowOrGroup<TRow>): row is Group<TRow>;
    protected isRow(row: RowOrGroup<TRow> | undefined): row is TRow;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableBodyComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DataTableBodyComponent<any>, "datatable-body", never, { "rowDefTemplate": { "alias": "rowDefTemplate"; "required": false; }; "scrollbarV": { "alias": "scrollbarV"; "required": false; }; "scrollbarH": { "alias": "scrollbarH"; "required": false; }; "loadingIndicator": { "alias": "loadingIndicator"; "required": false; }; "ghostLoadingIndicator": { "alias": "ghostLoadingIndicator"; "required": false; }; "externalPaging": { "alias": "externalPaging"; "required": false; }; "rowHeight": { "alias": "rowHeight"; "required": false; }; "offsetX": { "alias": "offsetX"; "required": false; }; "selectionType": { "alias": "selectionType"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "rowIdentity": { "alias": "rowIdentity"; "required": false; }; "rowDetail": { "alias": "rowDetail"; "required": false; }; "groupHeader": { "alias": "groupHeader"; "required": false; }; "selectCheck": { "alias": "selectCheck"; "required": false; }; "displayCheck": { "alias": "displayCheck"; "required": false; }; "trackByProp": { "alias": "trackByProp"; "required": false; }; "rowClass": { "alias": "rowClass"; "required": false; }; "groupedRows": { "alias": "groupedRows"; "required": false; }; "groupExpansionDefault": { "alias": "groupExpansionDefault"; "required": false; }; "innerWidth": { "alias": "innerWidth"; "required": false; }; "groupRowsBy": { "alias": "groupRowsBy"; "required": false; }; "virtualization": { "alias": "virtualization"; "required": false; }; "summaryRow": { "alias": "summaryRow"; "required": false; }; "summaryPosition": { "alias": "summaryPosition"; "required": false; }; "summaryHeight": { "alias": "summaryHeight"; "required": false; }; "rowDraggable": { "alias": "rowDraggable"; "required": false; }; "rowDragEvents": { "alias": "rowDragEvents"; "required": false; }; "disableRowCheck": { "alias": "disableRowCheck"; "required": false; }; "pageSize": { "alias": "pageSize"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "columns": { "alias": "columns"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "rowCount": { "alias": "rowCount"; "required": false; }; "bodyHeight": { "alias": "bodyHeight"; "required": false; }; "verticalScrollVisible": { "alias": "verticalScrollVisible"; "required": false; }; }, { "scroll": "scroll"; "page": "page"; "activate": "activate"; "select": "select"; "rowContextmenu": "rowContextmenu"; "treeAction": "treeAction"; }, never, ["[loading-indicator]", "[empty-content]"], true, never>;
}

declare class DataTableHeaderComponent implements OnDestroy, OnChanges {
    private cd;
    private scrollbarHelper;
    sortAscendingIcon?: string;
    sortDescendingIcon?: string;
    sortUnsetIcon?: string;
    scrollbarH?: boolean;
    dealsWithGroup?: boolean;
    targetMarkerTemplate?: TemplateRef<unknown>;
    enableClearingSortState: boolean;
    set innerWidth(val: number);
    get innerWidth(): number;
    sorts: SortPropDir[];
    sortType: SortType;
    allRowsSelected?: boolean;
    selectionType?: SelectionType;
    reorderable?: boolean;
    verticalScrollVisible: boolean;
    dragEventTarget?: MouseEvent | TouchEvent;
    set headerHeight(val: any);
    get headerHeight(): any;
    set columns(val: TableColumnInternal[]);
    get columns(): any[];
    set offsetX(val: number);
    get offsetX(): number;
    sort: EventEmitter<SortEvent>;
    reorder: EventEmitter<ReorderEventInternal>;
    resize: EventEmitter<ColumnResizeEventInternal>;
    resizing: EventEmitter<ColumnResizeEventInternal>;
    select: EventEmitter<void>;
    columnContextmenu: EventEmitter<{
        event: MouseEvent;
        column: TableColumnInternal;
    }>;
    _columnsByPin: PinnedColumns[];
    _columnGroupWidths: any;
    _innerWidth: number;
    _offsetX: number;
    _columns: TableColumnInternal[];
    _headerHeight: string;
    _styleByGroup: {
        left: NgStyle['ngStyle'];
        center: NgStyle['ngStyle'];
        right: NgStyle['ngStyle'];
    };
    private destroyed;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    onLongPressStart({ event, model }: {
        event: MouseEvent | TouchEvent;
        model: TableColumnInternal<Row>;
    }): void;
    onLongPressEnd({ model }: {
        model: TableColumnInternal<Row>;
    }): void;
    get headerWidth(): string;
    onColumnResized({ width, column }: {
        width: number;
        column: TableColumnInternal;
    }): void;
    onColumnResizing({ width, column }: {
        width: number;
        column: TableColumnInternal;
    }): void;
    private makeResizeEvent;
    onColumnReordered(event: ReorderEventInternal): void;
    onTargetChanged({ prevIndex, newIndex, initialIndex }: TargetChangedEvent): void;
    getColumn(index: number): any;
    onSort({ column, prevValue, newValue }: InnerSortEvent): void;
    calcNewSorts(column: SortableTableColumnInternal, prevValue: SortDirection | undefined, newValue: SortDirection | undefined): SortPropDir[];
    setStylesByGroup(): void;
    calcStylesByGroup(group: 'center' | 'right' | 'left'): NgStyle['ngStyle'];
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableHeaderComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DataTableHeaderComponent, "datatable-header", never, { "sortAscendingIcon": { "alias": "sortAscendingIcon"; "required": false; }; "sortDescendingIcon": { "alias": "sortDescendingIcon"; "required": false; }; "sortUnsetIcon": { "alias": "sortUnsetIcon"; "required": false; }; "scrollbarH": { "alias": "scrollbarH"; "required": false; }; "dealsWithGroup": { "alias": "dealsWithGroup"; "required": false; }; "targetMarkerTemplate": { "alias": "targetMarkerTemplate"; "required": false; }; "enableClearingSortState": { "alias": "enableClearingSortState"; "required": false; }; "innerWidth": { "alias": "innerWidth"; "required": false; }; "sorts": { "alias": "sorts"; "required": false; }; "sortType": { "alias": "sortType"; "required": false; }; "allRowsSelected": { "alias": "allRowsSelected"; "required": false; }; "selectionType": { "alias": "selectionType"; "required": false; }; "reorderable": { "alias": "reorderable"; "required": false; }; "verticalScrollVisible": { "alias": "verticalScrollVisible"; "required": false; }; "headerHeight": { "alias": "headerHeight"; "required": false; }; "columns": { "alias": "columns"; "required": false; }; "offsetX": { "alias": "offsetX"; "required": false; }; }, { "sort": "sort"; "reorder": "reorder"; "resize": "resize"; "resizing": "resizing"; "select": "select"; "columnContextmenu": "columnContextmenu"; }, never, never, true, never>;
}

declare class DatatableComponent<TRow extends Row = any> implements OnInit, DoCheck, AfterViewInit, AfterContentInit, OnDestroy {
    private scrollbarHelper;
    private cd;
    private columnChangesService;
    private configuration;
    /**
     * Template for the target marker of drag target columns.
     */
    targetMarkerTemplate?: TemplateRef<unknown>;
    /**
     * Rows that are displayed in the table.
     */
    set rows(val: (TRow | undefined)[] | null | undefined);
    /**
     * Gets the rows.
     */
    get rows(): (TRow | undefined)[];
    /**
     * This attribute allows the user to set the name of the column to group the data with
     */
    set groupRowsBy(val: keyof TRow | undefined);
    get groupRowsBy(): keyof TRow | undefined;
    /**
     * This attribute allows the user to set a grouped array in the following format:
     *  [
     *    {groupid=1} [
     *      {id=1 name="test1"},
     *      {id=2 name="test2"},
     *      {id=3 name="test3"}
     *    ]},
     *    {groupid=2>[
     *      {id=4 name="test4"},
     *      {id=5 name="test5"},
     *      {id=6 name="test6"}
     *    ]}
     *  ]
     */
    groupedRows?: Group<TRow>[];
    /**
     * Columns to be displayed.
     */
    set columns(val: TableColumn[]);
    /**
     * Get the columns.
     */
    get columns(): TableColumn[];
    /**
     * List of row objects that should be
     * represented as selected in the grid.
     * Default value: `[]`
     */
    selected: TRow[];
    /**
     * Enable vertical scrollbars
     */
    scrollbarV: boolean;
    /**
     * Enable vertical scrollbars dynamically on demand.
     * Property `scrollbarV` needs to be set `true` too.
     * Width that is gained when no scrollbar is needed
     * is added to the inner table width.
     */
    scrollbarVDynamic: boolean;
    /**
     * Enable horz scrollbars
     */
    scrollbarH: boolean;
    /**
     * The row height; which is necessary
     * to calculate the height for the lazy rendering.
     */
    rowHeight: number | 'auto' | ((row: TRow) => number);
    /**
     * Type of column width distribution formula.
     * Example: flex, force, standard
     */
    columnMode: ColumnMode | keyof typeof ColumnMode;
    /**
     * The minimum header height in pixels.
     * Pass a falsey for no header
     */
    headerHeight: number;
    /**
     * The minimum footer height in pixels.
     * Pass falsey for no footer
     */
    footerHeight: number;
    /**
     * If the table should use external paging
     * otherwise its assumed that all data is preloaded.
     */
    externalPaging: boolean;
    /**
     * If the table should use external sorting or
     * the built-in basic sorting.
     */
    externalSorting: boolean;
    /**
     * The page size to be shown.
     * Default value: `undefined`
     */
    set limit(val: number | undefined);
    /**
     * Gets the limit.
     */
    get limit(): number | undefined;
    /**
     * The total count of all rows.
     * Default value: `0`
     */
    set count(val: number);
    /**
     * Gets the count.
     */
    get count(): number;
    /**
     * The current offset ( page - 1 ) shown.
     * Default value: `0`
     */
    set offset(val: number);
    get offset(): number;
    /**
     * Show the linear loading bar.
     * Default value: `false`
     */
    loadingIndicator: boolean;
    /**
     * Show ghost loaders on each cell.
     * Default value: `false`
     */
    set ghostLoadingIndicator(val: boolean);
    get ghostLoadingIndicator(): boolean;
    /**
     * Type of row selection. Options are:
     *
     *  - `single`
     *  - `multi`
     *  - `checkbox`
     *  - `multiClick`
     *  - `cell`
     *
     * For no selection pass a `falsey`.
     * Default value: `undefined`
     */
    selectionType?: SelectionType;
    /**
     * Enable/Disable ability to re-order columns
     * by dragging them.
     */
    reorderable: boolean;
    /**
     * Swap columns on re-order columns or
     * move them.
     */
    swapColumns: boolean;
    /**
     * The type of sorting
     */
    sortType: SortType;
    /**
     * Array of sorted columns by property and type.
     * Default value: `[]`
     */
    sorts: SortPropDir[];
    /**
     * Css class overrides
     */
    cssClasses: Partial<Required<NgxDatatableConfig>['cssClasses']>;
    /**
     * Message overrides for localization
     *
     * @defaultValue
     * ```
     * {
     *   emptyMessage: 'No data to display',
     *   totalMessage: 'total',
     *   selectedMessage: 'selected',
     *   ariaFirstPageMessage: 'go to first page',
     *   ariaPreviousPageMessage: 'go to previous page',
     *   ariaPageNMessage: 'page',
     *   ariaNextPageMessage: 'go to next page',
     *   ariaLastPageMessage: 'go to last page'
     * }
     * ```
     */
    messages: Partial<Required<NgxDatatableConfig>['messages']>;
    /**
     * A function which is called with the row and should return either:
     * - a string: `"class-1 class-2`
     * - a Record<string, boolean>: `{ 'class-1': true, 'class-2': false }`
     */
    rowClass?: (row: TRow) => string | Record<string, boolean>;
    /**
     * A boolean/function you can use to check whether you want
     * to select a particular row based on a criteria. Example:
     *
     *    (selection) => {
     *      return selection !== 'Ethel Price';
     *    }
     */
    selectCheck?: (value: TRow, index: number, array: TRow[]) => boolean;
    /**
     * A function you can use to check whether you want
     * to show the checkbox for a particular row based on a criteria. Example:
     *
     *    (row, column, value) => {
     *      return row.name !== 'Ethel Price';
     *    }
     */
    displayCheck?: (row: TRow, column: TableColumn, value?: any) => boolean;
    /**
     * A boolean you can use to set the detault behaviour of rows and groups
     * whether they will start expanded or not. If ommited the default is NOT expanded.
     *
     */
    groupExpansionDefault: boolean;
    /**
     * Property to which you can use for custom tracking of rows.
     * Example: 'name'
     */
    trackByProp?: string;
    /**
     * Property to which you can use for determining select all
     * rows on current page or not.
     */
    selectAllRowsOnPage: boolean;
    /**
     * A flag for row virtualization on / off
     */
    virtualization: boolean;
    /**
     * Tree from relation
     */
    treeFromRelation?: string;
    /**
     * Tree to relation
     */
    treeToRelation?: string;
    /**
     * A flag for switching summary row on / off
     */
    summaryRow: boolean;
    /**
     * A height of summary row
     */
    summaryHeight: number;
    /**
     * A property holds a summary row position: top/bottom
     */
    summaryPosition: string;
    /**
     * A function you can use to check whether you want
     * to disable a row. Example:
     *
     *    (row) => {
     *      return row.name !== 'Ethel Price';
     *    }
     */
    disableRowCheck?: (row: TRow) => boolean;
    /**
     * A flag to enable drag behavior of native HTML5 drag and drop API on rows.
     * If set to true, {@link rowDragEvents} will emit dragstart and dragend events.
     */
    rowDraggable: boolean;
    /**
     * A flag to controll behavior of sort states.
     * By default sort on column toggles between ascending and descending without getting removed.
     * Set true to clear sorting of column after performing ascending and descending sort on that column.
     */
    enableClearingSortState: boolean;
    /**
     * Body was scrolled typically in a `scrollbarV:true` scenario.
     */
    scroll: EventEmitter<ScrollEvent>;
    /**
     * A cell or row was focused via keyboard or mouse click.
     */
    activate: EventEmitter<ActivateEvent<TRow>>;
    /**
     * A cell or row was selected.
     */
    select: EventEmitter<SelectEvent<TRow>>;
    /**
     * Column sort was invoked.
     */
    sort: EventEmitter<SortEvent>;
    /**
     * The table was paged either triggered by the pager or the body scroll.
     */
    page: EventEmitter<PageEvent>;
    /**
     * Columns were re-ordered.
     */
    reorder: EventEmitter<ReorderEvent>;
    /**
     * Column was resized.
     */
    resize: EventEmitter<ColumnResizeEvent>;
    /**
     * The context menu was invoked on the table.
     * type indicates whether the header or the body was clicked.
     * content contains either the column or the row that was clicked.
     */
    tableContextmenu: EventEmitter<ContextMenuEvent<TRow>>;
    /**
     * A row was expanded ot collapsed for tree
     */
    treeAction: EventEmitter<{
        row: TRow;
        rowIndex: number;
    }>;
    /**
     * Emits HTML5 native drag events.
     * Only emits dragenter, dragover, drop events by default.
     * Set {@link rowDraggble} to true for dragstart and dragend.
     */
    rowDragEvents: EventEmitter<DragEventData>;
    /**
     * CSS class applied if the header height if fixed height.
     */
    get isFixedHeader(): boolean;
    /**
     * CSS class applied to the root element if
     * the row heights are fixed heights.
     */
    get isFixedRow(): boolean;
    /**
     * CSS class applied to root element if
     * vertical scrolling is enabled.
     */
    get isVertScroll(): boolean;
    /**
     * CSS class applied to root element if
     * virtualization is enabled.
     */
    get isVirtualized(): boolean;
    /**
     * CSS class applied to the root element
     * if the horziontal scrolling is enabled.
     */
    get isHorScroll(): boolean;
    /**
     * CSS class applied to root element is selectable.
     */
    get isSelectable(): boolean;
    /**
     * CSS class applied to root is checkbox selection.
     */
    get isCheckboxSelection(): boolean;
    /**
     * CSS class applied to root if cell selection.
     */
    get isCellSelection(): boolean;
    /**
     * CSS class applied to root if single select.
     */
    get isSingleSelection(): boolean;
    /**
     * CSS class added to root element if mulit select
     */
    get isMultiSelection(): boolean;
    /**
     * CSS class added to root element if mulit click select
     */
    get isMultiClickSelection(): boolean;
    /**
     * Column templates gathered from `ContentChildren`
     * if described in your markup.
     */
    columnTemplates: QueryList<DataTableColumnDirective<TRow>>;
    /**
     * Row Detail templates gathered from the ContentChild
     */
    rowDetail?: DatatableRowDetailDirective;
    /**
     * Group Header templates gathered from the ContentChild
     */
    groupHeader?: DatatableGroupHeaderDirective;
    /**
     * Footer template gathered from the ContentChild
     */
    footer?: DatatableFooterDirective;
    /**
     * Reference to the body component for manually
     * invoking functions on the body.
     */
    bodyComponent: DataTableBodyComponent<TRow & {
        treeStatus?: TreeStatus;
    }>;
    /**
     * Reference to the header component for manually
     * invoking functions on the header.
     */
    headerComponent: DataTableHeaderComponent;
    private bodyElement;
    rowDefTemplate?: TemplateRef<any>;
    /**
     * Returns if all rows are selected.
     */
    get allRowsSelected(): boolean;
    element: HTMLElement;
    rowDiffer: KeyValueDiffer<TRow, TRow>;
    _innerWidth: number;
    pageSize: number;
    bodyHeight: number;
    rowCount: number;
    _offsetX: number;
    _limit: number | undefined;
    _count: number;
    _offset: number;
    _rows: (TRow | undefined)[];
    _groupRowsBy?: keyof TRow;
    _internalRows: (TRow | undefined)[];
    _internalColumns: TableColumnInternal<TRow>[];
    _columns: TableColumn[];
    _subscriptions: Subscription[];
    _ghostLoadingIndicator: boolean;
    _defaultColumnWidth?: number;
    protected verticalScrollVisible: boolean;
    private _rowInitDone;
    constructor();
    /**
     * Lifecycle hook that is called after data-bound
     * properties of a directive are initialized.
     */
    ngOnInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * view has been fully initialized.
     */
    ngAfterViewInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * content has been fully initialized.
     */
    ngAfterContentInit(): void;
    /**
     * This will be used when displaying or selecting rows.
     * when tracking/comparing them, we'll use the value of this fn,
     *
     * (`fn(x) === fn(y)` instead of `x === y`)
     */
    rowIdentity: (x: RowOrGroup<TRow>) => unknown;
    /**
     * Translates the templates to the column objects
     */
    translateColumns(val: QueryList<DataTableColumnDirective<TRow>>): void;
    /**
     * Creates a map with the data grouped by the user choice of grouping index
     *
     * @param originalArray the original array passed via parameter
     * @param groupBy the key of the column to group the data by
     */
    groupArrayBy(originalArray: (TRow | undefined)[], groupBy: keyof TRow): {
        key: TRow[keyof TRow];
        value: TRow[];
    }[];
    ngDoCheck(): void;
    /**
     * Recalc's the sizes of the grid.
     *
     * Updated automatically on changes to:
     *
     *  - Columns
     *  - Rows
     *  - Paging related
     *
     * Also can be manually invoked or upon window resize.
     */
    recalculate(): void;
    /**
     * Window resize handler to update sizes.
     */
    onWindowResize(): void;
    /**
     * Recalulcates the column widths based on column width
     * distribution mode and scrollbar offsets.
     */
    recalculateColumns(columns?: TableColumnInternal[], forceIdx?: number, allowBleed?: boolean): TableColumn[] | undefined;
    /**
     * Recalculates the dimensions of the table size.
     * Internally calls the page size and row count calcs too.
     *
     */
    recalculateDims(): void;
    /**
     * Recalculates the pages after a update.
     */
    recalculatePages(): void;
    /**
     * Body triggered a page event.
     */
    onBodyPage(offset: number): void;
    /**
     * The body triggered a scroll event.
     */
    onBodyScroll(event: ScrollEvent): void;
    /**
     * The footer triggered a page event.
     */
    onFooterPage(event: PagerPageEvent): void;
    /**
     * Recalculates the sizes of the page
     */
    calcPageSize(): number;
    /**
     * Calculates the row count.
     */
    calcRowCount(): number;
    /**
     * The header triggered a contextmenu event.
     */
    onColumnContextmenu({ event, column }: {
        event: MouseEvent;
        column: TableColumn;
    }): void;
    /**
     * The body triggered a contextmenu event.
     */
    onRowContextmenu({ event, row }: {
        event: MouseEvent;
        row: RowOrGroup<TRow>;
    }): void;
    /**
     * The header triggered a column resize event.
     */
    onColumnResize({ column, newValue, prevValue }: ColumnResizeEventInternal): void;
    onColumnResizing({ column, newValue }: ColumnResizeEventInternal): void;
    /**
     * The header triggered a column re-order event.
     */
    onColumnReorder(event: ReorderEventInternal): void;
    /**
     * The header triggered a column sort event.
     */
    onColumnSort(event: SortEvent): void;
    /**
     * Toggle all row selection
     */
    onHeaderSelect(): void;
    /**
     * A row was selected from body
     */
    onBodySelect(event: SelectEvent<TRow>): void;
    /**
     * A row was expanded or collapsed for tree
     */
    onTreeAction(event: {
        row: TRow;
    }): void;
    ngOnDestroy(): void;
    /**
     * listen for changes to input bindings of all DataTableColumnDirective and
     * trigger the columnTemplates.changes observable to emit
     */
    private listenForColumnInputChanges;
    private sortInternalRows;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DatatableComponent<any>, "ngx-datatable", never, { "targetMarkerTemplate": { "alias": "targetMarkerTemplate"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "groupRowsBy": { "alias": "groupRowsBy"; "required": false; }; "groupedRows": { "alias": "groupedRows"; "required": false; }; "columns": { "alias": "columns"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "scrollbarV": { "alias": "scrollbarV"; "required": false; }; "scrollbarVDynamic": { "alias": "scrollbarVDynamic"; "required": false; }; "scrollbarH": { "alias": "scrollbarH"; "required": false; }; "rowHeight": { "alias": "rowHeight"; "required": false; }; "columnMode": { "alias": "columnMode"; "required": false; }; "headerHeight": { "alias": "headerHeight"; "required": false; }; "footerHeight": { "alias": "footerHeight"; "required": false; }; "externalPaging": { "alias": "externalPaging"; "required": false; }; "externalSorting": { "alias": "externalSorting"; "required": false; }; "limit": { "alias": "limit"; "required": false; }; "count": { "alias": "count"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "loadingIndicator": { "alias": "loadingIndicator"; "required": false; }; "ghostLoadingIndicator": { "alias": "ghostLoadingIndicator"; "required": false; }; "selectionType": { "alias": "selectionType"; "required": false; }; "reorderable": { "alias": "reorderable"; "required": false; }; "swapColumns": { "alias": "swapColumns"; "required": false; }; "sortType": { "alias": "sortType"; "required": false; }; "sorts": { "alias": "sorts"; "required": false; }; "cssClasses": { "alias": "cssClasses"; "required": false; }; "messages": { "alias": "messages"; "required": false; }; "rowClass": { "alias": "rowClass"; "required": false; }; "selectCheck": { "alias": "selectCheck"; "required": false; }; "displayCheck": { "alias": "displayCheck"; "required": false; }; "groupExpansionDefault": { "alias": "groupExpansionDefault"; "required": false; }; "trackByProp": { "alias": "trackByProp"; "required": false; }; "selectAllRowsOnPage": { "alias": "selectAllRowsOnPage"; "required": false; }; "virtualization": { "alias": "virtualization"; "required": false; }; "treeFromRelation": { "alias": "treeFromRelation"; "required": false; }; "treeToRelation": { "alias": "treeToRelation"; "required": false; }; "summaryRow": { "alias": "summaryRow"; "required": false; }; "summaryHeight": { "alias": "summaryHeight"; "required": false; }; "summaryPosition": { "alias": "summaryPosition"; "required": false; }; "disableRowCheck": { "alias": "disableRowCheck"; "required": false; }; "rowDraggable": { "alias": "rowDraggable"; "required": false; }; "enableClearingSortState": { "alias": "enableClearingSortState"; "required": false; }; "rowIdentity": { "alias": "rowIdentity"; "required": false; }; }, { "scroll": "scroll"; "activate": "activate"; "select": "select"; "sort": "sort"; "page": "page"; "reorder": "reorder"; "resize": "resize"; "tableContextmenu": "tableContextmenu"; "treeAction": "treeAction"; "rowDragEvents": "rowDragEvents"; }, ["rowDetail", "groupHeader", "footer", "rowDefTemplate", "columnTemplates"], ["[loading-indicator]", "[empty-content]"], true, never>;
    static ngAcceptInputType_scrollbarV: unknown;
    static ngAcceptInputType_scrollbarVDynamic: unknown;
    static ngAcceptInputType_scrollbarH: unknown;
    static ngAcceptInputType_headerHeight: unknown;
    static ngAcceptInputType_footerHeight: unknown;
    static ngAcceptInputType_externalPaging: unknown;
    static ngAcceptInputType_externalSorting: unknown;
    static ngAcceptInputType_limit: unknown;
    static ngAcceptInputType_count: unknown;
    static ngAcceptInputType_offset: unknown;
    static ngAcceptInputType_loadingIndicator: unknown;
    static ngAcceptInputType_ghostLoadingIndicator: unknown;
    static ngAcceptInputType_reorderable: unknown;
    static ngAcceptInputType_swapColumns: unknown;
    static ngAcceptInputType_groupExpansionDefault: unknown;
    static ngAcceptInputType_selectAllRowsOnPage: unknown;
    static ngAcceptInputType_virtualization: unknown;
    static ngAcceptInputType_summaryRow: unknown;
    static ngAcceptInputType_summaryHeight: unknown;
    static ngAcceptInputType_rowDraggable: unknown;
    static ngAcceptInputType_enableClearingSortState: unknown;
}

declare class DatatableRowDetailTemplateDirective {
    static ngTemplateContextGuard(directive: DatatableRowDetailTemplateDirective, context: unknown): context is RowDetailContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDetailTemplateDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDetailTemplateDirective, "[ngx-datatable-row-detail-template]", never, {}, {}, never, never, true, never>;
}

declare class DataTableColumnHeaderDirective {
    static ngTemplateContextGuard(directive: DataTableColumnHeaderDirective, context: unknown): context is HeaderCellContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableColumnHeaderDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableColumnHeaderDirective, "[ngx-datatable-header-template]", never, {}, {}, never, never, true, never>;
}

declare class DataTableColumnCellDirective {
    template: TemplateRef<CellContext<any>>;
    static ngTemplateContextGuard(dir: DataTableColumnCellDirective, ctx: any): ctx is CellContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableColumnCellDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableColumnCellDirective, "[ngx-datatable-cell-template]", never, {}, {}, never, never, true, never>;
}

declare class DataTableColumnGhostCellDirective {
    static ngTemplateContextGuard(directive: DataTableColumnGhostCellDirective, context: unknown): context is void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableColumnGhostCellDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableColumnGhostCellDirective, "[ngx-datatable-ghost-cell-template]", never, {}, {}, never, never, true, never>;
}

declare class DataTableColumnCellTreeToggle {
    template: TemplateRef<any>;
    static ɵfac: i0.ɵɵFactoryDeclaration<DataTableColumnCellTreeToggle, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataTableColumnCellTreeToggle, "[ngx-datatable-tree-toggle]", never, {}, {}, never, never, true, never>;
}

declare class DatatableGroupHeaderTemplateDirective {
    static ngTemplateContextGuard(directive: DatatableGroupHeaderTemplateDirective, context: unknown): context is GroupContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableGroupHeaderTemplateDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableGroupHeaderTemplateDirective, "[ngx-datatable-group-header-template]", never, {}, {}, never, never, true, never>;
}

/**
 * Row Disable Directive
 * Use this to disable/enable all children elements
 * Usage:
 *  To disable
 * 		<div [disabled]="true" disable-row >
 * 		</div>
 *  To enable
 *  	<div [disabled]="false" disable-row >
 * 		</div>
 */
declare class DisableRowDirective {
    private readonly elementRef;
    readonly disabled: i0.InputSignalWithTransform<boolean, unknown>;
    constructor();
    private disableAllElements;
    static ɵfac: i0.ɵɵFactoryDeclaration<DisableRowDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DisableRowDirective, "[disable-row]", never, { "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}

/**
 * This component is passed as ng-template and rendered by BodyComponent.
 * BodyComponent uses rowDefInternal to first inject actual row template.
 * This component will render that actual row template.
 */
declare class DatatableRowDefComponent {
    rowDef: DatatableRowDefInternalDirective;
    rowContext: {
        disabled: boolean;
        template: TemplateRef<unknown>;
        rowTemplate: TemplateRef<unknown>;
        row: RowOrGroup<unknown>;
        index: number;
    };
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DatatableRowDefComponent, "datatable-row-def", never, {}, {}, never, never, true, never>;
}
declare class DatatableRowDefDirective {
    static ngTemplateContextGuard(_dir: DatatableRowDefDirective, ctx: unknown): ctx is RowDefContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDefDirective, "[rowDef]", never, {}, {}, never, never, true, never>;
}
/**
 * @internal To be used internally by ngx-datatable.
 */
declare class DatatableRowDefInternalDirective implements OnInit {
    vc: ViewContainerRef;
    rowDefInternal: RowDefContext;
    rowDefInternalDisabled?: boolean;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefInternalDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDefInternalDirective, "[rowDefInternal]", never, { "rowDefInternal": { "alias": "rowDefInternal"; "required": false; }; "rowDefInternalDisabled": { "alias": "rowDefInternalDisabled"; "required": false; }; }, {}, never, never, true, never>;
}
type RowDefContext = {
    template: TemplateRef<unknown>;
    rowTemplate: TemplateRef<unknown>;
    row: RowOrGroup<unknown>;
    index: number;
};

declare class NgxDatatableModule {
    /**
     * Configure global configuration via INgxDatatableConfig
     * @param configuration
     */
    static forRoot(configuration: AllPartial<NgxDatatableConfig>): ModuleWithProviders<NgxDatatableModule>;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgxDatatableModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NgxDatatableModule, never, [typeof DataTableFooterTemplateDirective, typeof DatatableComponent, typeof DataTableColumnDirective, typeof DatatableRowDetailDirective, typeof DatatableGroupHeaderDirective, typeof DatatableRowDetailTemplateDirective, typeof DataTableColumnHeaderDirective, typeof DataTableColumnCellDirective, typeof DataTableColumnGhostCellDirective, typeof DataTableColumnCellTreeToggle, typeof DatatableFooterDirective, typeof DatatableGroupHeaderTemplateDirective, typeof DisableRowDirective, typeof DatatableRowDefComponent, typeof DatatableRowDefDirective], [typeof DatatableComponent, typeof DatatableRowDetailDirective, typeof DatatableGroupHeaderDirective, typeof DatatableRowDetailTemplateDirective, typeof DataTableColumnDirective, typeof DataTableColumnHeaderDirective, typeof DataTableColumnCellDirective, typeof DataTableColumnGhostCellDirective, typeof DataTableColumnCellTreeToggle, typeof DataTableFooterTemplateDirective, typeof DatatableFooterDirective, typeof DatatableGroupHeaderTemplateDirective, typeof DisableRowDirective, typeof DatatableRowDefComponent, typeof DatatableRowDefDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NgxDatatableModule>;
}

/**
 * service to make DatatableComponent aware of changes to
 * input bindings of DataTableColumnDirective
 */
declare class ColumnChangesService {
    private columnInputChanges;
    get columnInputChanges$(): Observable<void>;
    onInputChange(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ColumnChangesService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ColumnChangesService>;
}

declare function toInternalColumn<T extends Row>(columns: TableColumn<T>[] | QueryList<DataTableColumnDirective<T>>, defaultColumnWidth?: number): TableColumnInternal<T>[];
declare function isNullOrUndefined<T>(value: T | null | undefined): value is null | undefined;

export { ColumnChangesService, ColumnMode, ContextmenuType, DataTableColumnCellDirective, DataTableColumnCellTreeToggle, DataTableColumnDirective, DataTableColumnGhostCellDirective, DataTableColumnHeaderDirective, DataTableFooterTemplateDirective, DatatableComponent, DatatableFooterDirective, DatatableGroupHeaderDirective, DatatableGroupHeaderTemplateDirective, DatatableRowDefComponent, DatatableRowDefDirective, DatatableRowDefInternalDirective, DatatableRowDetailDirective, DatatableRowDetailTemplateDirective, DisableRowDirective, NgxDatatableModule, SelectionType, SortDirection, SortType, isNullOrUndefined, providedNgxDatatableConfig, toInternalColumn };
export type { ActivateEvent, AllDetailToggleEvent, AllGroupsToggleEvent, CellContext, ColumnResizeEvent, ContextMenuEvenHeader, ContextMenuEvent, ContextMenuEventBody, DetailToggleEvent, DetailToggleEvents, DragEventData, DragEventType, FooterContext, Group, GroupContext, GroupToggleEvent, GroupToggleEvents, HeaderCellContext, NgxDatatableConfig, NgxDatatableCssClasses, NgxDatatableMessages, PageEvent, PagerPageEvent, ReorderEvent, Row, RowDetailContext, RowOrGroup, ScrollEvent, SelectEvent, SortEvent, SortPropDir, TableColumn, TableColumnProp, TreeStatus };
